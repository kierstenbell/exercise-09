---
title: "Exercise 09"
output: html_document
date: "2024-03-18"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Step 1 
- Using the {tidyverse} read_csv() function, load the “Street_et_al_2017.csv” dataset from this URL as a “tibble” named d.
- Do a quick exploratory data analysis where you generate the five-number summary (median, minimum and maximum and 1st and 3rd quartile values), plus mean and standard deviation, for each quantitative variable.

```{r echo=TRUE, message=FALSE}
# Set up libraries
library(tidyverse)
library(skimr)
library(tidyr)
library(broom)
```

```{r, 1}
f <- "https://raw.githubusercontent.com/difiore/ada-2024-datasets/main/Street_et_al_2017.csv"
d <- read_csv(f, col_names = TRUE)

# Quick glance
head(d)

# From {skimr}; provides n_missing, mean, sd, and five number summary (min, max, Q1, median, Q3)
skim(d)

# Make it a tibble 
# (tibble_d <- skim(d) 
#  tibble::as_tibble())

# You can also easily use group_by function to ...group...by... variables
# d %>%
#  dplyr::group_by(Species) %>%
#  skim()

```

### Step 2 
- From this dataset, plot brain size (ECV) as a function of social group size (Group_size), longevity (Longevity), juvenile period length (Weaning), and reproductive lifespan (Repro_lifespan).

```{r, 2}

par(mfrow = c(2, 2))
plot(data = d, ECV ~ Group_size, main = "Social Group Size", ylab = "Brain Size (ECV)")
plot(data = d, ECV ~ Longevity, main = "Longevity", ylab = "Brain Size (ECV)")
plot(data = d, ECV ~ Weaning, main = "Juvenile Period Length", ylab = "Brain Size (ECV)")
plot(data = d, ECV ~ Repro_lifespan, main = "Reproductive Lifespan", ylab = "Brain Size (ECV)")
```

### Step 3
- Derive by hand the ordinary least squares regression coefficients $\beta1$ and $\beta0$ for ECV as a function of social group size

```{r, 3}
# I do not understand why this yields diff results; B1 = 2.718; B0 = -172.906
# Solve for Beta1, slope, by hand
# (B1 <- cor(d$ECV, d$Group_size, use = "complete.obs") * (sd(d$ECV, na.rm = TRUE)/sd(d$Group_size, na.rm = TRUE)))

# Solve for Beta0, intercept, by hand 
# (B0 <- mean(d$ECV, na.rm = TRUE) - B1*mean(d$Group_size, na.rm = TRUE)) 

# Removing rows in ECV and Group_size that are not complete
ECV_GS_noNA <- d[complete.cases(d[ , c('ECV', 'Group_size')]), ]

# Rename the variables 
ECV <- ECV_GS_noNA$ECV
Group_size <- ECV_GS_noNA$Group_size

# Solve for Beta1 (slope) by hand
(beta1 <- cor(ECV, Group_size) * (sd(ECV)/sd(Group_size)))

# Solve for Beta0 (intercept) by hand
(beta0 <- mean(ECV) - beta1 * mean(Group_size))

```

### Step 4
- Confirm that you get the same results using the lm() function 

```{r, 4}
(ECV_GS <- lm(ECV ~ Group_size, data = d))
```


### Step 5
- Repeat the analysis above for three different major radiations of primates - “catarrhines”, “platyrrhines”, and “strepsirhines”) separately. These are stored in the variable Taxonomic_group. Do your regression coefficients differ among groups? How might you determine this?
- The intercepts (B0) vary between the groups, but the slopes (B1) are more similar. 


```{r, 5}
cat <- filter(ECV_GS_noNA, Taxonomic_group == "Catarrhini")
cat_lm <- lm(ECV ~ Group_size, data = cat)
plat <- filter(ECV_GS_noNA, Taxonomic_group == "Platyrrhini")
plat_lm <- lm(ECV ~ Group_size, data = plat)
strep <- filter(ECV_GS_noNA, Taxonomic_group == "Strepsirhini")
strep_lm <- lm(ECV ~ Group_size, data = strep)

# Combine results into a single data frame
# from {tidyr} and {broom}
cat_lm <- tidy(cat_lm) %>%
  mutate(Primate = "Catarrhini")
plat_lm <- tidy(plat_lm) %>%
  mutate(Primate = "Platyrrhini")
strep_lm <- tidy (strep_lm) %>%
  mutate(Primate = "Strepsirhini")
(primate_lm <- bind_rows(cat_lm, plat_lm, strep_lm, .id = "Model"))

```

### Step 6


```{r, 6}

```

### Step 7


```{r, 7}

```

### Step 8 

```{r, 8}


```
